# Redis の設定ファイル

# メモリサイズの記述形式について # {{{
# メモリサイズの指定が必要となる部分では 1k, 5GB, 4MB などの方法で設定可能です。
#
# 1k    => 1000 bytes
# 1kb   => 1024 bytes
# 1m    => 1000000 bytes
# 1mb   => 1024*1024 bytes
# 1g    => 1000000000 bytes
# 1gb   => 1024*1024*1024 bytes
#
# 単位に関しては大文字と小文字の区別はしないため、1GB/1Gb/1gB はどれも同じ意味になります。 # }}}

################################## 外部設定ファイル読み込み ###################################

# 外部設定ファイルの読み込み # {{{
# ひとつ以上の設定ファイルを読み込む事が可能です。
# 全ての Redis サーバで共通のテンプレートを使用しつつ、サーバ毎にカスタマイズが必要な部分を
# 別のファイルとして切り分けるといった場合に有用です。
# 読み込まれるファイルの中でさらに別のファイルを読み込むことも可能です。
#
# "include" オプションは管理者による "CONFIG REWRITE" コマンドや Redis Sentinel によって
# 書き換えられることはありません。
# Redis は常に設定ディレクティブの値として最後に読み込む値を使用するので、
# 動作時に設定を上書きすることを避けたいのであれば include はこのファイルの先頭部分に
# 記述した方がよいでしょう。
#
# 逆に include で設定オプションを上書きしたいのであれば、ファイルの最後に記述するとよいでしょう。
# }}}
# include /path/to/local.conf
# include /path/to/other.conf

############################# 起動モードの設定 ##############################

# Redis をデーモンで動かす場合は yes を指定。
# デーモンとして動作する場合、Redis は pidを pidfile で指定したファイルに書き込みます。
daemonize yes

# デーモンとして起動するときの pid ファイル
pidfile /var/run/redis/redis.pid

# コネクションを受け付けるポート。デフォルトは 6379
# 0 を指定するとTCP socket で listen しません。
port 6379

# Redis がバインドするネットワークインターフェイスの指定# {{{
# bind オプションが指定されなかった場合すべてのインタフェースで listen します。
# "bind" の設定でひとつもしくは複数のインターフェイスを指定できます。
# 以下の書式で指定できます。# }}}
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1

# コネクションで使用する Unix ドメインソケットの指定。デフォルトでは使用しません。
# unixsocket /tmp/redis.sock
# unixsocketperm 755

# クライアントとの通信がアイドル状態の時にコネクションを close するまでの時間(秒)
# 0 を指定するとタイムアウト無効
timeout 1800

# 0 以外の場合、クライアントとの無通信時に TCP ACK を送るのに SO_KEEPALIVE を利用。
# 無効な peer の検出や、ネットワーク維持で役立つ。推奨値は 60 (秒)。
tcp-keepalive 60

# サーバのログの情報量の設定 # {{{
# debug     多くの情報を出します。開発/テスト用。
# verbose   あまり重要でない情報も含めて多くの情報を出力するが debug よりは少ない。
# notice    運用時に使用するのに適した適度なログ出力
# warnig    重要でクリティカルなメッセージのみ # }}}
loglevel notice

# ログファイル名 # {{{
# "stdout" を指定するとRedisは標準出力にログを出力します。
# ただし、デーモンとして起動しているときに標準出力にログを出そうとしても、
# /dev/null に出力されてしまうので注意してください。 # }}}
logfile /var/log/redis/redis.log

# syslog を使用するかどうかの指定。yes の場合は関連パラメータも指定する。
# syslog-enabled no

# syslog の identity の指定
# syslog-ident redis

# syslog facility の指定。通常 USER か local0-7 を設定する。
# syslog-facility local0

# データベース数 # {{{
# 使用可能なデータベースの数を設定します。デフォルトのデータベースは DB 0 です。
# ユーザは SELECT <dbid> でコネクションごとに違うデータベースを選択できます。
# dbid には、0 から 'databases - 1' まで設定可能です。 # }}}
databases 16

############################## スナップショットの設定 ###############################
#
# データベースをディスクに保存するタイミング # {{{
#
#   save <seconds> <changes>
#
#   最後に save してから <seconds> 秒間に <changes> 回以上の書き込み命令を受け付けると
#   バックグラウンドで save(=bgsave) が発生します。
#   bgsave はforkしてプロセスをブロックしません。
#   書き込みが多いシステムだと Redis が使用中のメモリと同じメモリ量が必要になります（最大）。
#
#   save 900 1      # 900秒(15分)の間に1回以上キーの変更が発生
#   save 300 10     # 300秒(5分)の間に10回以上キーの変更が発生
#   save 60 10000   # 60秒の間に10,000回以上キーの変更が発生
#
#   save 行をすべてコメントアウトすると、保存が行われなくなります。
#   以下を追加することでも無効化が可能です。
#   save ""
# # }}}
save 900 1
save 300 10
save 60 10000

# スナップショット作成失敗時の挙動 # {{{
# RDB スナップショットが有効（少なくともひとつsave 設定がある）で bgsave に失敗した場合、
# Redis はデフォルトで書き込みを停止します(=yes)。
# （乱暴な挙動ではありますが）これによりに永続化データが適切に保存されていないことに気づけます。
# Redis サーバを適切に監視しているのであればこの設定を無効化することで(=no) 、
# 動作させ続けることが可能になります。 # }}}
stop-writes-on-bgsave-error no

# ダンプ時の文字列オブジェクト圧縮 # {{{
# .rdb にダンプするときに、文字列オブジェクトをLZFを使って圧縮するかどうかの設定。
# デフォルトでは "yes" になっており、常に圧縮するようになっています。
# 保存時にCPUパワーを節約したい場合は "no" を設定します。
# 圧縮可能なデータがある場合は、データセットサイズはより大きくなります。 # }}}
rdbcompression yes

# RDB のチェックサムの使用 # {{{
# RDB の version 5 から CRC64 チェックサムがファイルの末尾に追加されます。
# これにより構造がデータの変造に対してより強固なものとなりますが、
# 書き込みと読み込み時のパフォーマンスがおよそ10％程低下します。
# チェックサムを無効化して作成された RDB ファイルはゼロのチェックサムを持つことになり、
# 読み込み時にチェックがスキップされます。 # }}}
rdbchecksum yes

# ダンプファイル名
dbfilename dump.rdb

# 作業ディレクトリ # {{{
# DB ファイルは dbfilename で指定したファイル名でこのディレクトリ内に作成されます。
# AOF(Append Only File) もこのディレクトリに作成されます。 # }}}
dir /var/lib/redis

############################### レプリケーション #################################

# 他の Redis(master) の slave として動作させる設定 # {{{
# Master-Slave 形式のレプリケーションの設定を行います。
# slaveof の設定で Redis インスタンスを他の Redis サーバのコピーとして稼働させます。
# この設定はローカルなもので、例えば master とは異なる間隔で bgsave を実行する、
# 別のポートを使用するなどの設定も可能です。 # }}}
# slaveof <masterip> <masterport>

# master の認証パス # {{{
# master がパスワードで保護されている場合(requirepass 設定ディレクティブが有効)、
# slave に対してレプリケーションを開始する前に認証を要求することが可能です。
# 認証ができない場合 master は slave からのリクエストを拒否します。 # }}}
# masterauth <master-password>

# レプリケーションが正常でない状態の slave の挙動 # {{{
# master とのコネクションを失った時やレプリケーションが進行中の状態の時（初回同期など）、
# slave の挙動として2つの動作状態を選択できます。
#
# yes: クライアントからのリクエストに応答する（デフォルト）。
#      ただしこれは期限切れのデータや空のデータを返すことがあるかもれしれません。
# no:  INFO と SLAVEOF を除くすべてのコマンドに対して "SYNC with master in progress" を返す。 # }}}
slave-serve-stale-data no

# slave を書き込み可能にするか # {{{
# master との再同期を実行することで slave のみに保持されたデータを削除することができるので、
# 一時的なデータを格納したい場合などには slave への書き込みは有用です。
# ただし設定ミスによって問題が生じるかもしれません。
# Version 2.6 以降、 slave はデフォルトで read-only 設定になっています。
#
# read only の slave は信頼性の低いクライアントやインターネットからの利用を
# 想定しているわけではありません。この機能はあくまでもインスタンスの誤用に対しての保護機能です。
# read only の slave はデフォルトではすべての管理系コマンド（CONFIG、DEBUG など）が有効です。
# read only の slave に対して "rename-command" を使用することですべての管理系コマンド、
# 利用されると危険なコマンドを隠蔽することが可能なのでセキュリティを高めることが可能です。 # }}}
slave-read-only yes

# master への PING 応答確認の実行間隔 # {{{
# slave は指定の間隔で master に PING を送信します。この間隔は以下で設定できます。
# デフォルトは10秒です。 # }}}
repl-ping-slave-period 10

# レプリケーションのタイムアウト設定 # {{{
# レプリケーションにおける以下を対象とするタイムアウト設定です。デフォルトは60秒です。
#
# 1) slave 側から見た SYNC 実行時の一括データ転送のI/O
# 2) slave 側から見た master のタイムアウト（data, pings）
# 3) master 側から見た slave のタイムアウト（REPLCONF ACK pings）
#
# この値は repl-ping-slave-period より大きい値である必要があります。
# repl-ping-slave-period より小さい値を指定すると master と slave 間のトラフィックが
# 少ない場合でもチェックの度にタイムアウトが検出されてしまいます。 # }}}
repl-timeout 60

# SYNC 実行時に TCP_NODELAY を無効にするかどうか # {{{
# "yes" の場合、Redis は TCP パケットの数をより少なくし slave へのデータ送信時の
# 帯域を減らしますが、slave でのデータが使用可能になるまでの遅延時間が増加します。
# Linux kernel のデフォルトでは最大40ミリ秒ほどです。
#
# "no" の場合、slave でデータが使用可能になるまでの遅延は現象しますが、
# 使用する帯域が増加します。
#
# Redis はデフォルトで低レイテンシに最適化されていますが、非常に大きなトラフィックがある場合や、
# master-slave 間のホップ数が大きいなどの場合は "yes" に設定するとよいでしょう。 # }}}
repl-disable-tcp-nodelay no

# レプリケーションの backlog サイズ# {{{
# レプリケーションの backlog のサイズの設定を行います。
# backlog とは slave のデータを蓄積するバッファのことです。
# slave との接続がしばらくの間切断された場合 slave は再接続を試みます。
# そういった場合は大体において完全な再同期は必要なく部分的な再同期で十分であり、
# この機能により slave が切断されて転送できなかったデータ部分のみを転送します。
#
# backlog サイズが大きければ、復帰後の部分再同期を行うために必要な領域が
# 確保できるため、より長い時間 slave のダウンに耐えることが可能になります。
#
# 少なくとも1台でも slave の接続があれば backlog は一度だけ割り当てられます。
## }}}
repl-backlog-size 100mb

# backlog が開放されるまでのTTL# {{{
# 一定時間 salve からの接続がない場合、backlog の領域は開放されます。
# 以下のオプションで最後に slave との接続が切断されてからの経過時間によって
# backlog のバッファを開放するように設定可能です。
#
# 0 を設定すると backlog のバッファ開放を行いません。
## }}}
# repl-backlog-ttl 3600

# slave のプライオリティ # {{{
# slave のプライオリティは Redis によって INFO として整数値で告知されます。
# この値は master が正常に動作しなくなった場合に slave を master に昇格させるときに
# Redis Sentinel によって使用されます。
#
# 小さい値が優先度が高い slave として扱われます。たとえば 10, 100, 25 の3つの slave が
# 存在する場合、Redis Sentinel は最小の 10 の値をもつ slave を選択します。
#
# ただし、0 の値を指定した場合、その slave は master に昇格させないことを意味します。
# 0 が指定されている場合は Redis Sentinel による master 昇格の対象からは除外されます。
# デフォルト値は 100 です。 # }}}
slave-priority 100

# master への書き込み停止の設定 # {{{
# lag が M 秒以下の slave が N 台を下回った場合に master への書き込み要求の受付を
# 停止させることが可能です。
#
# N 台以上の slave が "online" 状態である必要があります。
#
# lag は最後に slave から ping を受け取ってからの秒数で
# （指定の値以下（<=）である必要があります）、ping は通常毎秒送信されます。
#
# このオプションは N 台の slave が書き込み可能であることを保証するものではなく、
# 要件を満たす slave が確保されていない場合に書き込みがロストする期間を指定の時間内に
# 制限するというものです。
#
# 例えば lag が 10 秒以下の slave が少なくとも 3 台必要な場合は以下のようになります。
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# どちらか 1 つの設定を 0 にすると機能は無効化されます。
#
# デフォルトの設定は min-slaves-to-write が 0 （機能が無効化）で、min-slaves-max-lag が
# 10 に設定されています。# }}}
# min-slaves-to-write 0
# min-slaves-max-lag 10

################################## セキュリティ ###################################

# 認証パスワード # {{{
# クライアントからのコマンドを実行する前に、 AUTH を要求します。
# Redis が稼働しているホストへ信頼できないアクセスがある場合に有用です。
# 後方互換性を考慮し、また多くの場合認証の必要がないためコメントアウトしたままにしてください。
# （自身の管理下にあるサーバなどで実行する場合）
#
# 性能の良いマシンで稼働させている場合、Redis は15万回程度のパスワードチェックが可能です。
# 十分に強度の強いパスワードを設定しないと簡単に突破されます。 # }}}
# requirepass

# コマンド名の変更 # {{{
# 管理系のコマンド（CONFIG）などの危険なコマンドを推測が難しいコマンド名に変更できます。
# コマンド名の変更はAOFファイルにログとして記述されます。
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 空の文字列を指定することでコマンドを無効化することも可能です。 # }}}
# rename-command CONFIG ""

################################### リソース制限 ####################################

# 同時接続数 # {{{
# 同時に接続できるクライアント数を設定します。デフォルトでは10,000クライアントです。
# Redis がプロセスファイルリミットの設定を指定した値に変更する権限がない場合、
# '現状の上限 - 32' の値にセットされます（Redis 内部で使用する分が予約されます）。
# 最大接続数に達すると全ての新しいコネクションを閉じ、
# 'max number of clients reached' エラーを送信します。 # }}}
maxclients 10000

# Redis が使用するメモリ上限の設定 # {{{
# メモリの使用を指定された <bytes> に制限します。コメントアウトするとシステムの上限まで使用します。
# 上限に達すると、maxmemory-policy の設定に従ってキーの削除を試みます。
# maxmemory-policy によるキーの削除ができない場合や maxmemory-policy の設定が
# "noeviction" に設定されている場合、メモリーを使用するコマンド（SET、LPUSHなど）に対して
# エラーを返し始めます。ただし read-only のコマンド（GETなど）は引き続き使用可能です。
#
# このオプションは Redis をLRUキャッシュとして使用する場合や、
# "noeviction" ポリシーを使用しているインスタンスで上限を設定する場合に有用です。
#
# slave が接続されている場合、slave の出力バッファに RAM の領域がある程度必要なので
# maxmemory の値を少し低めに設定した方がよいでしょう。
# （ただしポリシー で "noeviction" が設定されている場合は不要です。） # }}}
# maxmemory <bytes>

# メモリ使用量が maxmemory に達した時の動作 # {{{
# maxmemory に達した時に Redis の挙動を設定します。以下の6つから選択します。
#
# volatile-lru      期限切れになったキーをLRUアルゴリズムに基づいて削除
# allkeys-lru       全てのキーを対象にLRUアルゴリズムに基づいて削除
# volatile-random   期限切れになったキーをランダムで削除
# allkeys-random    全てのキーを対象にランダムで削除
# volatile-ttl      抽出した期限切れキーの中でタイムスタンプがより過去のものから削除
# noeviction        期限切れのキーは削除されず、新規の追加でエラーを返す
#
# ※注意
#   これらのどのポリシーを利用しても、削除可能なキーがない場合は
#   書き込み命令に対してエラーを返します。
#   現時点で該当するコマンドは以下です。
#
#   set setnx setex append
#   incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#   sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#   zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#   getset mset msetnx exec sort
#
# デフォルトは volatile-lru です。 # }}}
maxmemory-policy volatile-lru

# LRU/TTLのアルゴリズムにおける抽出サンプル数 # {{{
# LRUと最小TTLに基づくポリシーが用いるアルゴリズムは精密なものではなく、
# メモリ節約のために近似のアルゴリズムになっており、
# チェックを行うサンプル数を任意で設定できるようになっています。
# デフォルトのサンプル数は 3 です。
# # }}}
maxmemory-samples 3

############################## 追記専用モード ###############################

# 追記専用モード # {{{
# Redis はデフォルトでデータセットを非同期でディスクにダンプします。
# この動作は多くのアプリケーションにとって十分なものですが、
# 不意の電源断時に書き込みデータをロストすることになります。
#
# 追記専用ファイル（AOF）はデータ永続化の点でより耐久性の高いものです。
# 例えばデフォルトのfsyncポリシー（後述のパラメータ）を使用する場合、
# 突発的な電源断などの障害において1秒間分の書き込みデータを失うだけで済みます。
# （appendfsync が everysec の場合）
#
# AOF と RDB は問題なく同時使用が可能です。
# AOF が起動時に有効になっている場合、Redis は AOF をロードします。
# AOF はより耐久性の保証の点でより優れたものと言えます。
#
# 詳細は以下を参照してください。
# http://redis.io/topics/persistence # }}}
appendonly yes

# 追記専用ファイル名 (default: "appendonly.aof")
appendfilename "appendonly.aof"

# 追記専用モードのfsync設定 # {{{
# fsync() がOSに対して出力バッファでなくディスクに実際に書き込む命令です。
# 実際にディスクに flush するか遅延書き込みになるかは OS によって異なります。
#
# Redis は3つのモードをサポートしています。
#
# no:       fsync を行わず、データの flush をOS に任せます。最も高速です。
# always:   追記専用ログ（append only log）へ書き込みが発生する度に fsync を行います。
#           最も安全なモードです
# everysec: fsync を1秒毎に行います。中間的なモードです。
#
# デフォルトは "everysec" で速度と安全性からみて最も妥当なモードです。
# 理解した上で "no" を設定するのであれば動作として OS に flush のタイミングを任せることになり、
# よりよいパフォーマンスを得ることができます。
# （しかしデータロスを許容できるのであればデフォルトのスナップショットを利用するのがよいでしょう。）
# 逆に動作としては大分遅くなりますが "always" にすれば "everysec" よりさらに安全性が増します。
#
# 詳細は以下を参照してください。
# http://antirez.com/post/redis-persistence-demystified.html
#
# よくわからない場合は "everysec" を使用してください。 # }}}
# appendfsync always
appendfsync everysec
# appendfsync no

# バックグラウンド書き込みプロセス実行時のメインプロセスでの fsync の動作 # {{{
# AOF fsync のポリシーが "always" か "everysec" に設定されていてバックグラウンド動作する
# save プロセス（bgsave もしくは AOF ログのバックグランド書き込み）が
# ディスクに大量のI/O負荷をかける場合、Linux 設定によっては fsync() 実行時に
# 長時間のブロックを発生させるかもしれません。
# 現時点ではこの問題への対応策はなく、別スレッドで実行される定期実行の fsync は
# 同期 write(2) 呼び出しをブロックしてしまいます。
#
# この問題を軽減させる対策として以下のオプションを用いることができます。
# このオプションを使用することで BGSAVE や BGREWRITEAOF が実行中の場合には
# メインプロセスで fsync() 呼び出しが行われなくなります。
#
# これはつまり別の子プロセスで save が実行中の間は Redis の耐久性は
# "appendfsync no" と同じ状態になるということです。
# 具体的にいうと、Linux のデフォルトの設定環境においては最悪のシナリオとして
# 30秒間のデータを失う可能性があるということです。
#
# ディスクI/Oの遅延が問題になっている場合、この設定を "yes" にしてください。
# 問題がなければ耐久性の観点からこの値は "no" のままにしておいてください。 # }}}
no-appendfsync-on-rewrite no

# AOF の自動書き換え # {{{
# AOF はすべての更新系クエリを追記するので稼働させているとファイルサイズが肥大し続けます。
# このファイルの書き換え作業を行うことで不要な記録が削除されファイルサイズが縮小されます。
# AOF のログサイズが設定値（増加％）に達した場合、 Redis は BGREWRITEAOF を呼び出すことで
# 暗黙のうちにログファイルの書き換えを実行します。
#
# Redis は書き換えを実行したあとの最新の AOF ファイルサイズを記憶します（基底のサイズ）。
# （再起動後に一度も書き換えが発生していない場合は起動時の AOF ファイルサイズが使用されます。）
#
# この基底となるサイズと現時点での AOF ファイルサイズを比較します。
# 増加サイズの割合が設定の割合（%）より大きくなると書き換え作業が発生します。
# （デフォルトの 100 の設定の場合、ファイルサイズが2倍になったら実行されるということです。）
# この設定には合わせて最小ファイルサイズの指定も行う必要があります。
# ファイルサイズが設定した最小サイズ以下の場合、増加の割合（%）が設定値を超えても
# 書き換えは実行されません。
#
# 設定値として 0 を指定した場合、AOF の自動書き換えは無効化されます。 # }}}
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

################################ LUA スクリプト  ###############################

# Lua スクリプトの最大実行時間の設定 # {{{
# Lua スクリプトの最大実行時間をミリ秒で設定します。
#
# 最大実行時間を超えた場合、Redis はスクリプトが実行中であることをログに記録し、
# クエリに対してエラーを返し始めます。
#
# スクリプトの実行がが最大実行時間を超えた場合、SCRIPT KILL と SHUTDOWN NOSAVE コマンドのみが
# 使用可能です。スクリプトで書き込みコマンドが呼び出されていない状態であれば SCRIPT KILL で
# スクリプトを停止できます。書き込みコマンドがスクリプトから実行されてユーザーがスクリプトの
# 実行が終わるのを待てない場合、SHUTDOWN NOSAVE コマンドでのみサーバを停止できます。
#
# 0 もしくは負の値を設定すると警告を発することなく制限を設けずにスクリプトを実行します。 # }}}
lua-time-limit 5000

################################## SLOW LOG ###################################

# slow log の設定概要 # {{{
# Redis の slow log は実行時間が閾値を超えるクエリを記録するシステムです。
# 実行時間にはクライアントとの通信による I/O にかかる時間は含まれません。
# 実際に実行されるコマンドに要する時間が対象となります。
# （コマンドが実行されスレッドをブロックし他のリクエストが処理できない状態になっている
# 段階のみが対象です）
#
# slow log に関するパラメータ設定は2つあります。
# ひとつは slow log として記録するコマンド実行時間の閾値で、マイクロ秒で指定します。
# ふたつめは slow log のサイズです。新しいコマンドがログとして記録された場合、
# 最も古いコマンドはログコマンドのキューから削除されます。 # }}}

# slow log の閾値 # {{{
# 設定はマイクロ秒です。つまり 1000000 が1秒に該当します。
# 負の値を指定すると slow log は無効になり、0 ですべてのコマンドを強制的にロギングします。 # }}}
slowlog-log-slower-than 10000

# slow log で記録する最大数 # {{{
# この値に上限はありませんが、大きい値にするとメモリを使い果たすことになるので注意してください。
# SLOWLOG RESET コマンドを使用することで slow log が使用しているメモリを開放できます。 # }}}
slowlog-max-len 128

############################# イベント通知 ##############################

# イベント通知の設定# {{{
# Redis はキー空間におけるイベントの発生についてを Pub/Sub クライアントに通知可能です。
# この機能の詳細は http:////redis.io/topics/keyspace-events にあります。
#
# 例えばキー空間のイベント通知が有効になっている状態で、クライアントが
# DEL のオペレーションを データベース番号 0 に保存されている"foo" キーに対して
# 実行した場合、2 つのメッセージが Pub/Sub によって発行されます。
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# Redis が通知するイベントはクラスセットから選択することが可能です。
# すべてのクラスは 1 文字で定義されています。
#
#  K     キー空間のイベント。 __keyspace@<db>__ をプレフィックスにして発行される。
#  E     キーイベントのイベント。 __keyevent@<db>__ をプレフィックスにして発行される。
#  g     一般的なコマンド（タイプ指定のないもの）。 DEL, EXPIRE, RENAME, など。
#  $     文字列型コマンド
#  l     リスト型コマンド
#  s     セット型コマンド
#  h     ハッシュ型コマンド
#  z     ソート済みセット型コマンド
#  x     Expire イベント (キーの expire が発生する度にイベント生成)
#  e     Evict イベント ( maxmemory の設定による evict が実行される時にイベント生成)
#  A     "g$lshzxe" 指定のエイリアス。"AKE" ですべてのイベントを指定できる。
#
# "notify-keyspace-events" は 1 つの引数をもちます。引数は空文字列もしくは複数の
# 文字列を取ります。空文字列はすべての通知を無効にすることを意味します。
#
# 例1：リスト型と一般コマンドのイベントを有効にする場合、イベント名の観点から
#      以下を指定します。
#
#       notify-keyspace-events Elg
#
# 例2：期限切れキーのストリームを取得するために __keyevent@0__:expired を
#      チャンネル名として購読します。
#
#       notify-keyspace-events Ex
#
# デフォルトではすべての通知は無効化されています。大多数のユーザーにとって
# この機能は必要なく、機能自体に若干のオーバーヘッドがあるからです。
# 注意点として、 K もしくは E の少なくともどちらかひとつの指定がないと
# イベントは伝達されません。# }}}
notify-keyspace-events ""

############################### 高度な設定 ###############################

# ハッシュ型データが ziplist 化される上限値 # {{{
# エントリ数（entries）が閾値以下かつエントリの最大データサイズ（value）が閾値を超えない場合、
# ハッシュ型データははメモリを効率良く使用するデータ構造（ziplist）にエンコードされます。
# 閾値を超える場合は通常のハッシュテーブルが使用されます。
# これらの閾値の設定は以下で行います。 # }}}
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# リスト型データが ziplist 化される上限値 # {{{
# ハッシュと同様に閾値以下に収まるデータサイズの場合、
# リスト型データはメモリ効率の良いデータ型（ziplist）にエンコードされます。
# これらの閾値の設定はは以下で行います。 # }}}
list-max-ziplist-entries 512
list-max-ziplist-value 64

# セット型データがエンコーディングされる場合のデータサイズ上限値 # {{{
# セット型は特定の条件下において特殊なエンコーディングの形式を持っています。
# すなわち、セット型のデータが10進数の64bit符号付き整数のみで構成される場合です。
# このエンコーディングが適応されるデータサイズの上限を以下で設定します。 # }}}
set-max-intset-entries 512

# ソート済みセット型データが ziplist 化される上限値 # {{{
# ハッシュ型やリスト型と同様にソート済みセット型もメモリ効率の良い ziplist エンコーディングに
# 対応しています。
# このエンコーディングが適応されるエントリ数と要素数の上限を以下で設定します。 # }}}
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# 能動的な再ハッシュ（active rehash） # {{{
# Redis は能動的な再ハッシュ（active rehash）で100ミリ秒ごとに1ミリ秒のCPU時間を使用して、
# top-level のキーと荒井を保持しているメインのハッシュテーブルの再ハッシュを行います。
# Redis のハッシュテーブルは遅延再ハッシュが実行できるように実装されています（dict.c参照）。
# 再ハッシュされいているハッシュテーブルに対して操作を行えば行うほど、
# より多くの再ハッシュのステップが実行されます。
# サーバがアイドル状態だろ再ハッシュは完了することなくより多くのメモリが
# ハッシュテーブルによって使用されることになります。
#
# 可能な限りメモリを開放するため、メインの辞書の能動的再ハッシュを行うのに
# デフォルトでは1秒間に1ミリ秒の時間を10回使用するようになっています。
#
# よくわからない場合:
# クエリの実行に2ミリ秒の遅延も許されないような環境や厳しい遅延要件のある環境においては、
# "activerehashing no" を設定してください。
#
# これらの厳しい要件が特になく可能な限り早くメモリ解放を行いたい場合は、
# "activerehashing yes" を設定してください。 # }}}
activerehashing yes

# クライアントの出力バッファの設定 # {{{
# クライアント出力バッファの制限によって、なんらかの原因によってサーバからのデータの読み出しに
# 十分な速度が出ていないクライアントを強制的に切断することが可能です。
# （よくある原因のひとつとして、 Pub/Sub のクライアント側（subscriber）のメッセージ処理速度が
# 発行者（publisher）の送出速度に追いついていないというものがあります。）
#
# 制限は3つの異なるクライアントのクラスに応じてそれぞれ別の設定が可能です。
#
# normal -> 通常のクライアント
# slave  -> slave クライアントと MONITOR クライアント
# pubsub -> 購読クライアント
#
# それぞれの client-output-buffer-limit ディレクティブの文法は以下です。
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# 出力バッファが hard limit に達したクライアントは即座に切断されます。
# また、soft limit に達して指定の秒数の間それが継続した場合も切断されます。
# 例を示します。hard limit が 32MB で soft limit が 16MB で 10秒に設定されている場合、
# 出力バッファが 32MB に達したクライアントは即座にコネクションが切断され、
# 16MB に達してそれが10秒以上続いた場合にも同様に切断されます。
#
# 通常のクライアントはリクエストを送らない限りデータを受信することはないので
# デフォルトでは制限を設けられていませんが、読み込み処理を上回る速さで
# データのリクエストを行う非同期なクライアントに対しては設定を設けたほうが良いでしょう。
#
# これに対しpubsub と slave のクライアントは push 型の実装なので、
# デフォルトで制限が設けられています。
#
# hard と soft の各制限は 0 を設定することで無効化できます。 # }}}
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# バックグラウンド処理の頻度 # {{{
# Redis はタイムアウトしたクライアントのコネクションクローズ、
# 使用されなくなった期限切れのキーの削除、その他の多くのバックグランドのタスクを行うために
# 内部機能を呼び出します。
#
# すべてのタスクが同じ頻度で実行されるわけではありませんが、
# Redis は 実行するタスクを "hz" の値に基づいてチェックします。
#
# デフォルトでは "hz" の値は 10 に設定されています。この値を増やすと Redis がアイドル状態の時に
# より多くの CPU を使用することになりますが、同時に多数の期限切れキーの削除を行ったり
# より正確なタイムアウト処理を行う場合などにおいて、より応答性がよくなります。
#
# 設定可能な範囲は 1 から 500 ですが、100 以上の値はおすすめできません。
# 多くのユーザーにとってはデフォルトの 10 が推奨設定です。
# レイテンシに対する要求が非常に大きな環境でのみ 100 へ設定をあげるべきです。 # }}}
hz 10

# AOF の書き換え時の fsync 設定 # {{{
# 子プロセスで AOF の書き換えが行われる時に、以下のオプションを有効にすることで
# 32MB 毎に fsync を実行するようになります。これはデータサイズがどんどん大きくなっていく
# ファイルをディスクに書き込むときに大きな遅延スパイクが発生するのを抑えるのに有用です。 # }}}
aof-rewrite-incremental-fsync yes

